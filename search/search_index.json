{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Predicting graph structure from a time series of graphs","text":"<p>This is a Python implementation of netseer. Netseer is a tool that outputs a predicted graph based on a time series graph sequence</p>"},{"location":"#purpose","title":"Purpose","text":"<p>The goal of netseer is to predict the graph structure including new nodes and edges from a time series of graphs. The methodology is explained in the preprint (Kandanaarachchi et al. 2025).</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>This package is available on PyPI, and can be installed with PIP or with a Package Manager:</p> <pre><code>pip install netseer # or uv add netseer\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Generating an example graph list:</p> <pre><code>from netseer import generate_graph\n\ngraph_list = generate_graph.generate_graph_list()\n</code></pre> <p>The <code>generate_graph_list()</code> function has parameters for templating what types of graphs to generate. Information about these can be found in the reference docs.</p> <p>Predicting on that graph:</p> <pre><code>from netseer import prediction\n\npredict = prediction.predict_graph(graph_list, h=1)\n</code></pre> <p>Increasing the <code>h</code> parameter increases how many steps into the future the prediction is, with <code>h=1</code> being 1 step in the graph sequence.</p>"},{"location":"#references","title":"References","text":"<p>Kandanaarachchi, Sevvandi, Ziqi Xu, Stefan Westerlund, and Conrad Sanderson. 2025.   \u201cPredicting Graph Structure via Adapted Flux Balance Analysis.\u201d https://arxiv.org/abs/2507.05806.</p>"},{"location":"references/","title":"References","text":""},{"location":"references/#introduction","title":"Introduction","text":"<p>User Facing Modules:</p> <ul> <li>generate_graph: Contains functions for creating new graphs e.g. A randomly growing list of graphs.</li> <li>prediction: Contains functions for predicting the next graph in a time-series list of graphs.</li> <li>utils: Contains helper functions, such as loading graphs from disk.</li> </ul> <p>Internally used Modules:</p> <ul> <li>forecasting: Internal functions that assist in predictions.</li> <li>netseer: Used for running via CLI for testing</li> </ul>"},{"location":"references/#prediction-module","title":"Prediction Module","text":"<p>Prediction Module:</p> Typical Usage Example <pre><code>from netseer import utils, generate_graph, prediction\nfrom pathlib import Path\n\n# Get the directory/folder with all the graphs.\ndirectory_path = Path.cwd() / Path(\"path/to/data\")\n# Use glob to get a list of absolute paths for .gml files.\ngraph_files = directory_path.glob(\"*.gml\"))\n\n# Load the graphs into igraph using the list of gml files.\ngraph_list = utils.read_graph_list(graph_files)\n# Predict the next graph.\npredict = prediction.predict_graph(graph_list, h=1)\n</code></pre>"},{"location":"references/#src.netseer.prediction.predict_graph","title":"<code>predict_graph(graph_list, h=5, conf_nodes=None, conf_degree=90, weights_option=4)</code>","text":"<p>From a list of graphs, predicts a new graph</p> <p>Parameters:</p> Name Type Description Default <code>graph_list</code> <code>Iterable[Graph]</code> <p>A list of graphs to be predicted on: See generate_graph_list()</p> required <code>h</code> <code>int</code> <p>How many steps into the future the prediction should be.</p> <code>5</code> <code>conf_nodes</code> <p>-- TODO</p> <code>None</code> <code>conf_degree</code> <code>int</code> <p>-- TODO</p> <code>90</code> <code>weights_option</code> <code>int</code> <p>Int between 1-7 determines the weight of newly created edges. 1-3: Weight 0 for all edges. 4: Weight 1 for all edges. 5: Linear scaling weights for new edges (x+1). E.g. 1, 2, 3 6: Proportional Weights. 7: Weight 0 for all edges, except for last edge which is 1.</p> <code>4</code> <p>Returns:</p> Type Description <code>Graph</code> <p>Predicted Graph.</p> Source code in <code>src/netseer/prediction.py</code> <pre><code>def predict_graph(\n    graph_list: Iterable[ig.Graph],\n    h: int = 5,\n    conf_nodes=None,\n    conf_degree: int = 90,\n    weights_option: int = 4,\n) -&gt; ig.Graph:\n    \"\"\"From a list of graphs, predicts a new graph\n\n    Args:\n        graph_list: A list of graphs to be predicted on: See generate_graph_list()\n        h: How many steps into the future the prediction should be.\n        conf_nodes: -- TODO\n        conf_degree: -- TODO\n        weights_option: Int between 1-7 determines the weight of newly created edges.\n            1-3: Weight 0 for all edges.\n            4: Weight 1 for all edges.\n            5: Linear scaling weights for new edges (x+1). E.g. 1, 2, 3\n            6: Proportional Weights.\n            7: Weight 0 for all edges, except for last edge which is 1.\n\n    Returns:\n        Predicted Graph.\n    \"\"\"\n\n    print(\"Forecasting properties of the new graph\")\n    # predict the number of nodes for the predicted graph\n    new_nodes, new_nodes_lower, new_nodes_upper = forecasting.predict_num_nodes(\n        graph_list, h=h, conf_level=conf_nodes\n    )\n    # predict the degrees for the new nodes\n    new_nodes_degrees = forecasting.predict_new_nodes_degrees(graph_list)\n\n    # predict the degrees of the existing nodes\n    existing_nodes_degrees = forecasting.predict_existing_nodes_degrees(\n        graph_list, h=h, conf_level=conf_degree\n    )\n\n    total_edges = forecasting.predict_total_edges_counts(\n        graph_list, h=h, conf_level=conf_degree\n    )\n\n    EDGES_CONF_LEVEL = \"conf_high\"  # \"mean\"\n    print(\"Using forecasts to predict the new graph\")\n    mean_graph = predict_graph_from_forecasts(\n        graph_list,\n        new_nodes,\n        existing_nodes_degrees[EDGES_CONF_LEVEL],\n        new_nodes_degrees,\n        total_edges[EDGES_CONF_LEVEL],\n        conf_nodes,\n        conf_degree,\n        weights_option,\n    )\n\n    print(\"done\")\n    return mean_graph\n</code></pre>"},{"location":"references/#utils-module","title":"Utils Module","text":"<p>Utility functions that help with dataloading</p> Typical functions <pre><code>from netseer import utils, prediction\nfrom pathlib import Path\n\n# Get the directory/folder with all the graphs.\ndirectory_path = Path.cwd() / Path(\"path/to/data\")\n# Use glob to get a list of absolute paths for .gml files.\ngraph_files = directory_path.glob(\"*.gml\"))\n\n# Load the graphs into igraph using the list of gml files.\ngraph_list = utils.read_graph_list(graph_files)\n\n# Then use the list of graphs for predictions.\npredict = prediction.predict_graph(graph_list, h=1)\n</code></pre> <p>read_graph_list()</p>"},{"location":"references/#src.netseer.utils.read_graph_list","title":"<code>read_graph_list(filenames)</code>","text":"<p>Reads a list graphs from disk.</p> <p>The graphs are read in index order, therefore the first graph in the time-series is at index 0.</p> <p>Parameters:</p> Name Type Description Default <code>filenames</code> <code>list[str]</code> <p>A list of absolute paths to ig.read compatible graphs. E.g. *.gml files.</p> required <p>Returns:</p> Type Description <code>list[Graph]</code> <p>A list of read graphs.</p> Source code in <code>src/netseer/utils.py</code> <pre><code>def read_graph_list(filenames: list[str]) -&gt; list[ig.Graph]:\n    \"\"\"Reads a list graphs from disk.\n\n    The graphs are read in index order, therefore the first graph in the time-series is at index 0.\n\n    Args:\n        filenames: A list of absolute paths to ig.read compatible graphs. E.g. *.gml files.\n\n    Returns:\n        A list of read graphs.\n    \"\"\"\n    # read a list of saved graph files\n    print(f\"Reading in graph files: {filenames}\")\n    return [ig.read(filename) for filename in filenames]\n</code></pre>"},{"location":"references/#src.netseer.utils.read_pickled_list","title":"<code>read_pickled_list(filename)</code>","text":"<p>Reads a saved list of graphs from a .pkl file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Absolute path to the .pkl file.</p> required <p>Returns:</p> Type Description <code>list[Graph]</code> <p>A list of graphs.</p> Source code in <code>src/netseer/utils.py</code> <pre><code>def read_pickled_list(filename: str) -&gt; list[ig.Graph]:\n    \"\"\"Reads a saved list of graphs from a .pkl file.\n\n    Args:\n        filename: Absolute path to the .pkl file.\n\n    Returns:\n        A list of graphs.\n    \"\"\"\n    # read a graph list that is stored in a single pickled file\n    print(f\"Reading pickled graph list from {filename}\")\n    return pickle.load(filename)\n</code></pre>"},{"location":"references/#generate-graph-module","title":"Generate Graph Module","text":"<p>Contains functions for generating a list of graphs.</p> Typical usage example <pre><code>from netseer import generate_graph, prediction\n\ngraph_list = generate_graph.generate_graph_list()\npredict = prediction.predict_graph(graph_list, h=1)\n</code></pre>"},{"location":"references/#src.netseer.generate_graph.generate_graph_list","title":"<code>generate_graph_list(start_nodes=1000, add_nodes=50, add_edges=200, rem_edges=100, nn_edges=3, num_iters=15, mode='linear')</code>","text":"<p>Randomly generate a list of graphs using supplied parameters.</p> <p>Parameters:</p> Name Type Description Default <code>start_nodes</code> <code>int</code> <p>Number of nodes the first graph will have.</p> <code>1000</code> <code>add_nodes</code> <code>int</code> <p>Number of nodes the graph will grow by each step.</p> <code>50</code> <code>add_edges</code> <code>int</code> <p>Number of edges the graph will grow by each step.</p> <code>200</code> <code>rem_edges</code> <code>int</code> <p>Number of edges that are removed each step.</p> <code>100</code> <code>num_iters</code> <code>int</code> <p>How many times should the graph grow.</p> <code>15</code> <code>mode</code> <code>str</code> <p>Graph growth method. Linear Growth = 'linear', Exponential growth = 'exp'</p> <code>'linear'</code> <p>Returns:</p> Type Description <code>list[Graph]</code> <p>A list of graphs, with index 0 being the first generated graph.</p> Source code in <code>src/netseer/generate_graph.py</code> <pre><code>def generate_graph_list(\n    start_nodes: int = 1000,\n    add_nodes: int = 50,\n    add_edges: int = 200,\n    rem_edges: int = 100,\n    nn_edges: int = 3,\n    num_iters: int = 15,\n    mode: str = \"linear\",\n) -&gt; list[ig.Graph]:\n    \"\"\"Randomly generate a list of graphs using supplied parameters.\n\n    Args:\n        start_nodes: Number of nodes the first graph will have.\n        add_nodes: Number of nodes the graph will grow by each step.\n        add_edges: Number of edges the graph will grow by each step.\n        rem_edges: Number of edges that are removed each step.\n        num_iters: How many times should the graph grow.\n        mode: Graph growth method. Linear Growth = 'linear', Exponential growth = 'exp'\n\n    Returns:\n        A list of graphs, with index 0 being the first generated graph.\n    \"\"\"\n    graph_list = [None] * num_iters\n    initial_graph = ig.Graph.Barabasi(n=start_nodes, directed=False)\n    graph_list[0] = initial_graph\n    for i in range(1, num_iters):\n        graph_list[i] = generate_next_graph(\n            graph_list[i - 1], add_nodes, add_edges, rem_edges, nn_edges\n        )\n    return graph_list\n</code></pre>"},{"location":"references/#forecasting-module","title":"Forecasting Module","text":"<p>Internal: Supplimentary functions for predictions.</p>"},{"location":"references/#netseer-module","title":"Netseer Module","text":"<p>Internal: This Module is only used for running Netseer via the CLI for testing.</p> Typical usage example <pre><code>python netseer.py --random_graph\n# As we use uv and it's hard to add in args, instead there is a script in pyproject.toml:\nuv run random\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#flow","title":"Flow","text":"<p>The general flow of processing with Netseer is:</p> <ul> <li>Load a time-series list of graphs.</li> <li>Predict the next graph in the series.</li> </ul>"},{"location":"tutorial/#getting-started","title":"Getting Started","text":"<p>For this tutorial, I'm defaulting to using uv. Otherwise set up a python project using pip/venv as standard and create a <code>main.py</code></p>"},{"location":"tutorial/#setup","title":"Setup","text":"<p>Create a python project:</p> <pre><code>uv init netseer-tutorial\ncd netseer-tutorial\n</code></pre> <p>Add the Netseer package:</p> <pre><code>uv add netseer # or pip install netseer\n</code></pre> <p>The tutorial takes place in the <code>main.py</code> file.</p>"},{"location":"tutorial/#loading","title":"Loading","text":"<p>There are two ways to create graphs:</p> <ul> <li>Creating your own list of graphs. Typically this would be a time-series list of graphs.</li> <li>Randomly generating a list of graphs using Netseer.</li> </ul>"},{"location":"tutorial/#using-own-graphs","title":"Using own graphs","text":"<p>If creating your own graphs, Netseer uses the python package <code>igraph</code> to handle graphs. Therefore, the created graphs need to be saved in a format that can be used by <code>igraph.Graph.Read</code>. For our tutorial we will used GML format graphs.</p> <p>Save the list of graphs into a directory/folder relative to your project. For example in a /data/ directory. E.g.:</p> <pre><code>data/\n\u251c\u2500\u2500 graph_1.gml\n\u251c\u2500\u2500 graph_2.gml\n\u2514\u2500\u2500 graph_3.gml\n</code></pre> <p>Then create a list of absolute paths. This is easily done using pathlib and glob.</p> <pre><code># Get the directory/folder with all the graphs.\ndirectory_path = Path.cwd() / Path(\"path/to/data\")\n# Use glob to get a list of absolute paths for .gml files.\ngraph_files = directory_path.glob(\"*.gml\"))\n</code></pre> <p>The <code>graph_files</code> will now contain the path to each graph, as a list. Similar to: <code>[\"home/code/netseer/data/graph_1.gml\", \"home/code/netseer/data/graph_2.gml\",\"home/code/netseer/data/graph_3.gml\"]</code></p> <p>Then use the imported utils function <code>read_graph_list()</code> on the <code>graph_files</code>. This reads each .gml file in the <code>graph_files</code> and loads them into a list of graphs, loaded in memory. The graphs are loaded in the index order in <code>graph_files</code>. Use a numbering system for the .gml file names so that <code>sorted</code> can arrange the graphs paths in descending order.</p> <pre><code># If you need to sort the graph names.\ngraph_files = sorted(graph_files)\n</code></pre> <p>After the optional sorting:</p> <pre><code># Load the graphs into igraph using the list of gml files.\ngraph_list = utils.read_graph_list(graph_files)\n</code></pre> <p>The graphs loaded this way are ordered by their filename, in descending order. So graph_1 would be at index 0, graph_2 at index 1 etc. The order of graphs are important for the prediction.</p>"},{"location":"tutorial/#using-random-graphs","title":"Using random graphs","text":"<p>Alternatively, Netseer has a function to create a random list of graphs. Instead of using pathlib, glob and <code>read_graph_list()</code>, import generate_graph and use the function <code>generate_graph_list</code> to create a random graph list that is already stored in memory.</p> <pre><code>from netseer import generate_graph\n\ngraph_list = generate_graph.generate_graph_list()\n</code></pre> <p>The <code>generate_graph_list()</code> function contains parameters to tailor the generated random graphs, such as growth rate. Refer to the references documentation for an explanation.</p>"},{"location":"tutorial/#prediction","title":"Prediction","text":"<p>After loading the graphs into memory, use the imported prediction function <code>predict_graph()</code> to predict the next graph in the series. Change the <code>h</code> parameter in <code>predict_graph</code> to predict that many steps into the future. E.g. 1 step, 2 steps, 3 steps etc.</p> <pre><code># Then use the list of graphs for predictions.\npredict = prediction.predict_graph(graph_list, h=1)\n</code></pre>"}]}